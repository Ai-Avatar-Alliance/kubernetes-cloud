---
description: Deploy and manage Virtual Servers using Terraform
---

# Terraform

Virtual Servers are a [Kubernetes Custom Resource](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/) on CoreWeave Cloud, which means the [Kubernetes Terraform provider](https://registry.terraform.io/providers/hashicorp/kubernetes/latest/docs) can be used to create and modify Virtual Servers as Custom Resources.

## Getting Started

**Before you can access CoreWeave Cloud, you must first** [**request an account**](https://cloud.coreweave.com/signup)**.**

To use the Terraform module as your deployment method, you will first need to obtain valid access credentials in the form of a `kubeconfig` file.

{% hint style="info" %}
**Note**

See [Obtain Access Credentials](../../docs/welcome-to-coreweave/getting-started.md#obtain-access-credentials) for more information.
{% endhint %}

With the [Virtual Server module](https://github.com/coreweave/kubernetes-cloud/tree/master/virtual-server/examples/terraform) cloned, and all [configuration options](../../docs/virtual-servers/virtual-server-configuration-options/) adjusted to your preferences, a Virtual Server can either be created by running the module directly:

```bash
$ terraform init
$ terraform plan
$ terraform apply -auto-approve
```

Or, if managing a fleet of Virtual Servers, then ideally their outputs can be consumed by new module definitions for each machine, or by other modules.

#### Example

```
module "virtualserver_1" {
  source               = "./coreweave/kubernetes-cloud/tree/master/virtual-server/examples/terraform"
  kubeconfig_path      = "./kube/config/kubeconfig"
  vs_name              = "myserver"
  vs_username          = "myuser"
  vs_generate_password = "true"
  user_namespace       = "mynamespace"
}
```

Repeating a single definition for additional machines, then managing each Virtual Server, can be done by using the `target` option:

```bash
$ terraform plan -target=module.virtualserver_1
$ terraform apply -target=module.virtualserver_1 -auto-approve
$ terraform destroy -target=module.virtualserver_1
```

Once deployed, the status of the new machine can be verified using `kubectl`:

```
$ kubectl get vs example-vs

NAME                STATUS               REASON                                           STARTED   INTERNAL IP      EXTERNAL IP
example-vs          Initializing         Waiting for VirtualMachineInstance to be ready   False                      123.123.123.123
```

{% hint style="info" %}
**Note**

The output of this command will include the Service External IP address for accessing the server.
{% endhint %}

### Output variables

As shown in the example above, this module has two output values that can be referenced as attributes by other modules.

#### Example

```
Apply complete! Resources: 0 added, 0 changed, 0 destroyed.

Outputs:

vs_network = "[address]"
vs_password = "[password]"
```

This will include the Service IP address and either the provided password or the one generated by Terraform as `vs_network` and `vs_password`, which can be referenced, for example, as outputs:

```
output "vs_network" {
  value = module.virtualserver_1.vs_network
}

output "vs_password" {
  value = module.virtualserver_1.vs_password
}
```

## Examples

CoreWeave provides [an example plan on GitHub](https://github.com/coreweave/kubernetes-cloud/tree/master/virtual-server/examples/terraform).

## Configuration quick reference

The table below is intended as a quick-reference guide for all available configuration options using the Kubernetes CLI deployment method. Learn more about each configuration option in their respective pages under [Virtual Server Configuration Options](../../docs/virtual-servers/virtual-server-configuration-options/).



<table><thead><tr><th width="257.61479933936556">Variable name</th><th width="150">Type</th><th>Description</th></tr></thead><tbody><tr><td>kubeconfig_path</td><td>string</td><td>The system path to the kubeconfig file to use</td></tr><tr><td>user_namespace</td><td>string</td><td>The namespace into which the Virtual Server will be deployed. <strong>Does not have a default value; must be set</strong></td></tr><tr><td>vs_name</td><td>string</td><td>The hostname for the Virtual Server</td></tr><tr><td>vs_username</td><td>string</td><td>Username for the virtual server <strong>Does not have a default value; must be set</strong></td></tr><tr><td>vs_generate_password</td><td>bool</td><td>When set to <code>true</code>,  a strong password is generated</td></tr><tr><td>vs_password</td><td>string</td><td>With vs_generate_password set to false, provide a password for vs_username</td></tr><tr><td>vs_memory</td><td>string</td><td>Memory requested in Gi (i.e. 16Gi)</td></tr><tr><td>vs_root_storage</td><td>string</td><td>The amount of storage requested for the root volume in Gi (i.e. <code>80Gi</code>)</td></tr><tr><td>vs_os_type</td><td>string</td><td>Virtual Server OS variant (i.e. linux)</td></tr><tr><td>vs_image</td><td>string</td><td>The name of the OS image to deploy to the Virtual Server</td></tr><tr><td>vs_gpu</td><td>string</td><td>The GPU model name for Virtual Server</td></tr><tr><td>vs_gpu_enable</td><td>bool</td><td>Enables a GPU for this Virtual Server</td></tr><tr><td>vs_gpu_count</td><td>int</td><td>The number of GPUs requested</td></tr><tr><td>vs_cpu_count</td><td>int</td><td>The number of CPUs requested</td></tr><tr><td>vs_region</td><td>string</td><td>The data center region in which to deploy the Virtual Server</td></tr><tr><td>vs_running</td><td>bool</td><td>Start the Virtual Server once deployed</td></tr><tr><td>vs_public_networking</td><td>bool</td><td>Enable public networking</td></tr><tr><td>vs_attach_loadbalancer</td><td>bool</td><td>Attach a Service Load Balancer IP directly to the Virtual Server (<code>vs_tcp_ports</code> and <code>vs_udp_ports</code> must be empty, if enabled)</td></tr><tr><td>vs_tcp_ports</td><td>list</td><td>A list of TCP ports to allow access to</td></tr><tr><td>vs_udp_ports</td><td>list</td><td>A list of UDP ports to allow access to</td></tr></tbody></table>
